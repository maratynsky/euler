(def a1 ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"])
(def a3 ["twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"])
(def hundred "hundred")
(def thousand "thousand")
(defn n2t [n] (let [t (int (/ n 1000))] (if (zero? t) [] [(get a1 (dec t)) thousand])))
(defn n2h [n] (let [t (int (/ (mod n 1000) 100))] (if (zero? t) [] [(get a1 (dec t)) hundred])))
(defn n2d [n] (let [t (int (mod n 100))] (if (< t 20) [(get a1 (dec t))] (let [d (int (/ t 10)) e (mod t 10)] [(get a3 (- d 2)) (get a1 (dec e))]))))
(defn x [a, b] (let [c (int (/ a b)) d (mod a b)] (if (zero? (* c d)) [] ["and"])))
(defn n2w [n] (concat (n2t n) (x n 1000) (n2h n) (x n 100) (n2d n)))
(defn num2word [n] (clojure.string/join (n2w n)))
(defn n2l [n] (count (num2word n)))
(reduce + (map n2l (range 1 1001)))
